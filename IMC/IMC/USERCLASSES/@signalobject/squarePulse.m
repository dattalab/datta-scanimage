% squarePulse(SIGNAL, amplitude, offset, delay, width) - Parameterizes this SIGNAL object as a single square pulse.
%
% SYNTAX
%   squarePulse(SIGNAL, amplitude, offset, delay, width)
%       SIGNAL - The signal object.
%       amplitude - The amplitude (in arbitrary units) of this analytic signal.
%       offset - The offset (in amplitude space) of this analytic signal.
%       delay - The offset (in time) of this analytic signal.
%       width - The width (duration) of the pulse.
%
% CHANGES
%  TO050605D: Use callthrough to squarePulseTrain, for elegance. -- Tim O'Connor 5/6/05
%
% Created: Timothy O'Connor 11/03/04 
% Copyright: Cold Spring Harbor Laboratories/Howard Hughes Medical Institute 2004
function squarePulse(this, amplitude, offset, delay, width)
global signalobjects;

squarePulseTrain(this, amplitude, offset, delay, width, 0, 1);

return;
% 
% if delay < 0
%     error('Negative delays are not allowed: %s', num2str(delay));
% elseif width < 0
%     error('Negative widths are not allowed: %s', num2str(width));
% end
% 
% pointer = indexOf(this);
% 
% set(this, 'Type', 'Recursive', 'Method', 'add', 'deleteChildrenAutomatically', 1);
% setDefaultsByType(this);
% 
% children = get(this, 'Children');
% 
% %Clear out unwanted objects.
% indices = [];
% for i = 1 : length(children)
%     if get(children(i), 'autogenerated')
%         indices(length(indices) + 1) = i;
%     end
% end
% if length(indices) == length(children)
%     delete(children);
% end
% 
% %Baseline
% kids(1) = signalobject;
% dc(kids(1), offset);
% p1 = indexOf(kids(1));
% signalobjects(p1).autogenerated = 1;
% signalobjects(p1).sampleRate = signalobjects(pointer).sampleRate;
% signalobjects(p1).deleteChildrenAutomatically = 1;
% 
% %Pulse
% kids(2) = signalobject;
% dc(kids(2), amplitude);
% p2 = indexOf(kids(2));
% signalobjects(p2).autogenerated = 1;
% signalobjects(p2).sampleRate = signalobjects(pointer).sampleRate;
% signalobjects(p2).length = width;
% signalobjects(p2).repeatable = 0;
% signalobjects(p2).deleteChildrenAutomatically = 1;
% 
% recursive(this, 'Add', kids, [0 delay]);
% 
% return;